# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GerarGrid
                                 A QGIS plugin
 Gera grade amostral Padrão Terram
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Igor Viana Souza - Terram Soluções Agronômica
        email                : igor.souzavigor@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import *
import processing
import sys, os
from osgeo import ogr
from PyQt5.QtCore import Qt
from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterVectorLayer
import processing
import os # This is is needed in the pyqgis console also
from qgis.core import (QgsVectorLayer)
import math
import qgis.core
from PyQt5.QtCore import QSettings, QVariant 
from qgis.utils import iface

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .GRID_dialog import GerarGridDialog
import os.path
import pdb


class GerarGrid:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GerarGrid_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GridAmostral')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GerarGrid', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
    
        icon_path = ':/plugins/GRID/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'GridAmostral'),
            callback=self.run,
            parent=self.iface.mainWindow())
        # Check if the toolbar already exists
        toolbar = iface.addToolBar('INVERTER BANDEIRA')

        if toolbar:
            # If the toolbar already exists, clear its contents
            for action in toolbar.actions():
                toolbar.removeAction(action)
        else:
            # If the toolbar doesn't exist, create a new one
            toolbar = QToolBar('INVERTER BANDEIRA')
            iface.addToolBar(toolbar)
                
        # will be set False in run()
        self.first_start = True
       
    
    def unload(self):
    
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GridAmostral'),
                action)
            self.iface.removeToolBarIcon(action)
    
   
        
    
    
    
    def carregaVetor(self):
        """layers vetoriais existente no projeto"""
        self.dlg.entrada.clear()
        lista_layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        lista_layer_vector =[]
        for layer in lista_layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                lista_layer_vector.append(layer.name())
        self.dlg.entrada.addItems(lista_layer_vector)     

    def abrirVetor(self):
        """Abre janela de dialogo para abrir um layer a ser aplicado"""
        camada_abrir =str(QFileDialog.getOpenFileName(caption="Escolha a camada...",filter = "Shapefiles (*.shp)")[0])
        if (camada_abrir !=""):
            item =(camada_abrir, str.split(os.path.basename(camada_abrir),".")[0])
            self.carregaVetor()
            self.dlg.entrada.addItems(item) 
    
    def saida1(self):
        salvar = str(QFileDialog.getSaveFileName(caption="Defina a layer de saída...",filter = "Shapefiles (*.shp)")[0])
        self.dlg.output.setText(salvar)
    
    
   
   
    
    def variaveis(self):
        self.largura = self.dlg.tolerancia.value()
        self.entrada = self.dlg.entrada.currentText()
        
        
    def ClassificarFarm(self):
       
        self.selected_layer_classificar = self.dlg.mMapLayerComboBoxFarm.currentLayer()      
    
    def AmostraEstratificar(self):
        
        self.selected_layer_amostra  = self.dlg.mMapLayerComboBoxAmostra.currentLayer()
        self.valor_verde = self.dlg.spinBoxLavouraVerde.value()
        self.valor_vermelho = self.dlg.spinBoxLavouraVermelho.value()
        self.valor_aviao = self.dlg.spinBoxLavouraAviao.value()
        self.valor_grade = self.dlg.spinBoxGrade.value()
        # self.Cliente = self.dlg.lineEditCliente.currentText()
        # self.Farm = self.dlg.lineEditFarm.currentText()
        # self.Et = self.dlg.lineEditEt.currentText()
        
    
    def exportarShp(self):
        
        self.saida1= self.dlg.mQgsFileWidget.filePath()
        self.saida= self.saida1 + '.shp'
        
        #self.saida = self.dlg.output.text()
        self.idinicial = self.dlg.idinicial.value()
        self.selected_layer  = self.dlg.layers.currentLayer()
        self.selected_layer_farm  = self.dlg.layersFarm.currentLayer()
        
        
       
        associacao_atributos = processing.run('native:joinattributesbylocation',{
        'DISCARD_NONMATCHING': False,
        'INPUT': self.selected_layer,
        'JOIN': self.selected_layer_farm,
        'JOIN_FIELDS': [''],
        'METHOD': 0,
        'NON_MATCHING': None,
        'OUTPUT': 'TEMPORARY_OUTPUT',
        'PREDICATE': [0,1,4,5],
        'PREFIX': ''
        })

        output_associacao = associacao_atributos['OUTPUT']
        #QgsProject.instance().addMapLayer(output_associacao)
       
        
        reprojetar= processing.run('native:reprojectlayer', 
        {
        'INPUT': output_associacao,
        'OPERATION': '',
        'TARGET_CRS': QgsCoordinateReferenceSystem("EPSG:4326"),
        'OUTPUT': 'TEMPORARY_OUTPUT'
        })
        point_wgs84 = reprojetar['OUTPUT']
        #QgsProject.instance().addMapLayer(point_wgs84)
                
           
            
        try:
            split_grid = processing.runAndLoadResults('native:splitvectorlayer',{
            'FIELD': 'GRID_2',
            'FILE_TYPE': 1,
            'INPUT': point_wgs84,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            })

            output_split_grid = split_grid['OUTPUT']
            
            list_geometry = []
            for files in os.listdir(output_split_grid):

                # load only the shapefiles
                if files.endswith(".shp"):

                    # create vector layer object
                    vlayer = QgsVectorLayer(output_split_grid + "/" + files, files, "ogr")
                    #QgsProject.instance().addMapLayer(vlayer)
                    list_geometry.append(vlayer)
            
            
            idinicial = self.idinicial
            idfield = 'ID_AJS'
            layer_list = list_geometry  # replace with your list of layers
            list_id_aj = []
            for layer in layer_list:
                formula = 'array_find(array_reverse(array_sort(array_agg(to_string(to_int($x))+\'|\'+ to_string(to_int($y))))), to_string(to_int($x))+\'|\'+ to_string(to_int($y)))+'
                formula_final = formula + str(idinicial)
                id = processing.run('native:fieldcalculator',{
                    'FIELD_LENGTH': 10,
                    'FIELD_NAME': idfield,
                    'FIELD_PRECISION': 0,
                    'FIELD_TYPE': 1,
                    'FORMULA': formula_final,
                    'INPUT': layer,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                id_output = id['OUTPUT']
                #QgsProject.instance().addMapLayer(id_output)
                
                coords = [[f.geometry().asPoint().x(), f.geometry().asPoint().y(), f.id()] for f in id_output.getFeatures()] #List x coordinate, y coordinate and id of each point
                coords.sort(key=lambda k: (k[1],-k[0]), reverse=True) #Sort by y, x
                order = [i[2] for i in coords] #Extract only the ids from the sorted list of lists
                attrMap = {}
                for new_id, old_id in enumerate(order, idinicial):
                    attrMap[old_id] = {id_output.fields().indexFromName(idfield): new_id}
                id_output.dataProvider().changeAttributeValues(attrMap)
                idinicial += len(order)
                list_id_aj.append(id_output)
            
            id_mesclado=processing.run('native:mergevectorlayers',{
            'CRS': None,
            'LAYERS':list_id_aj ,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            id_output = id_mesclado['OUTPUT']
            
            old_field_name = "ID_AJS"
            new_field_name = "ID"
            
            columns_to_delete_indx = point_wgs84.attributeList()
            id_output.startEditing()
            id_output.dataProvider().deleteAttributes(columns_to_delete_indx)
            id_output.commitChanges()
            

            layer = id_output
                        # Verifica se a camada está em modo de edição
            if not layer.isEditable():
                layer.startEditing()

            # Obtém a lista de atributos da camada
            fields = layer.fields()

            # Procura o índice do campo antigo
            old_field_index = fields.indexOf('ID_AJS')

            # Renomeia o campo antigo para o novo nome
            if old_field_index >= 0:
                layer.renameAttribute(old_field_index, 'ID')
                layer.updateFields()

            # Salva as alterações
            if layer.isModified():
                layer.commitChanges()

        except:
            pass
        
            columns_to_delete_indx = point_wgs84.attributeList()
            point_wgs84.startEditing()
            point_wgs84.dataProvider().deleteAttributes(columns_to_delete_indx)
            point_wgs84.commitChanges()
            
            numero = str(self.idinicial)
            formula = 'array_find(array_reverse(array_sort(array_agg(to_string(to_int($x))+\'|\'+ to_string(to_int($y))))), to_string(to_int($x))+\'|\'+ to_string(to_int($y)))+'
            formula_final = formula + numero 
            id=processing.run('native:fieldcalculator',{
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'ID',
            'FIELD_PRECISION': 0,
            'FIELD_TYPE': 1,
            'FORMULA': formula_final,
            'INPUT': point_wgs84,
            'OUTPUT': 'TEMPORARY_OUTPUT'

            })
            id_output = id['OUTPUT']
            idfield = 'ID' #Change to match the name of your field

            coords = [[f.geometry().asPoint().x(), f.geometry().asPoint().y(), f.id()] for f in id_output.getFeatures()] #List x coordinate, y coordinate and id of each point
            coords.sort(key=lambda k: (k[1],-k[0]), reverse=True) #Sort by y, x
            order = [i[2] for i in coords] #Extract only the ids from the sorted list of lists

            i = id_output.fields().indexFromName(idfield)
            attrMap = {id: {i:e} for e,id in enumerate(order,self.idinicial)}
            id_output.dataProvider().changeAttributeValues(attrMap)
        
        
        save = processing.run('native:savefeatures',{
        'DATASOURCE_OPTIONS': '',
        'INPUT':id_output ,
        'LAYER_NAME': 'Amostras',
        'LAYER_OPTIONS': '',
        'OUTPUT': self.saida
        })
        
        
        output = save['OUTPUT']
        point_layer = QgsVectorLayer(output, "Amostras", "ogr")
        point_layer.loadNamedStyle(os.path.join(self.plugin_dir,'waypoint_id.qml'))
        point_layer.triggerRepaint()
        point_layer=QgsProject.instance().addMapLayer(point_layer)
        
        
        contagem=processing.run('native:countpointsinpolygon',{
        'CLASSFIELD': '',
        'FIELD': 'AMOSTRAS',
        'POINTS': point_layer,
        'POLYGONS': "FARM",
        'WEIGHT': '',
        'OUTPUT': 'TEMPORARY_OUTPUT'
        })
        
        output_contagem = contagem['OUTPUT']
        
        estatistica= processing.run('qgis:statisticsbycategories',
        {
        'CATEGORIES_FIELD_NAME': ['GEOMETRIA', 'GRID', 'TALHAO','PONTOS', 'AMOSTRAS'],
        'INPUT': output_contagem,
        'OUTPUT': 'TEMPORARY_OUTPUT',
        'VALUES_FIELD_NAME': '',
        })
        output_estatistica = estatistica['OUTPUT']
        #QgsProject.instance().addMapLayer(output_estatistica)
         
        associacao_atributos = processing.run('native:joinattributesbylocation',{
        'DISCARD_NONMATCHING': False,
        'INPUT': point_layer,
        'JOIN': self.selected_layer_farm,
        'JOIN_FIELDS': [''],
        'METHOD': 0,
        'NON_MATCHING': None,
        'OUTPUT': 'TEMPORARY_OUTPUT',
        'PREDICATE': [0,1,4,5],
        'PREFIX': ''
        })
        import pandas as pd
        layer = associacao_atributos['OUTPUT']
        #QgsProject.instance().addMapLayer(layer)
       # Create an empty dictionary to store the count and ID range of features for each grid value
        grid_info = {}

        # Loop through the features and update the count and ID range of features for each grid value
        request = QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry)
        for feature in layer.getFeatures(request):
            grid_value = feature['GRID']
            id_value = feature['ID']
            if grid_value in grid_info:
                grid_info[grid_value]['count'] += 1
                if id_value < grid_info[grid_value]['Min']:
                    grid_info[grid_value]['Min'] = id_value
                if id_value > grid_info[grid_value]['Max']:
                    grid_info[grid_value]['Max'] = id_value
            else:
                grid_info[grid_value] = {'count': 1, 'Min': id_value, 'Max': id_value}

        # Convert the grid_info dictionary to a pandas DataFrame
        df = pd.DataFrame.from_dict(grid_info, orient='index', columns=['count', 'Min', 'Max'])
        df.index.name = 'GRID'
        df.reset_index(inplace=True)

        # Update the 'Min' and 'Max' columns with the minimum and maximum values of the 'ID' field, respectively
        min_values = []
        max_values = []
        for index, row in df.iterrows():
            grid_value = row['GRID']
            request = QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry).setFilterExpression(f"GRID = '{grid_value}'")
            features = layer.getFeatures(request)
            id_values = [f['ID'] for f in features]
            min_values.append(min(id_values))
            max_values.append(max(id_values))

        df['Min'] = min_values
        df['Max'] = max_values
       # Create a new QgsVectorLayer with no geometry
        temp = QgsVectorLayer("none", "Resumo", "memory")
        temp_data = temp.dataProvider()

        # Start editing the layer
        temp.startEditing()

        # Create fields in the layer based on the columns in the DataFrame
        for head in df.columns:
            # Get the data type of the column
            data_type = df[head].dtype
            if data_type == 'float64':
                # Column has data type float, create a QgsField with data type QVariant.Double
                myField = QgsField(head, QVariant.Double)
            elif data_type == 'int64':
                # Column has data type integer, create a QgsField with data type QVariant.Int
                myField = QgsField(head, QVariant.Int)
            else:
                # Column has some other data type, create a QgsField with data type QVariant.String
                myField = QgsField(head, QVariant.String)
            temp.addAttribute(myField)

        # Update the fields in the layer
        temp.updateFields()

        # Add features to the layer based on the rows in the DataFrame
        for row in df.itertuples():
            # Create a new QgsFeature
            f = QgsFeature()
            # Set the attributes of the feature based on the values in the DataFrame row
            attrs = [getattr(row, col) for col in df.columns]
            f.setAttributes(attrs)
            # Add the feature to the layer
            temp.addFeature(f)

        # Commit changes and add the layer to the project
        temp.commitChanges()
        QgsProject.instance().addMapLayer(temp)

   
          
    def handleCheckboxStateChangeLavoura(self):
        
        if self.dlg.radioButtonLavoura.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
           
            self.dlg.groupBoxLavoura.setEnabled(True)
        else:
            self.dlg.groupBoxLavoura.setEnabled(False)
            
            
            
    def handleCheckboxStateChangeAberturaLavoura(self):
        
        if self.dlg.radioButtonAbertura.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
            self.Padrao =  'ABERTURA'
        
        
        if self.dlg.radioButtonLavoura.isChecked() == True:
            self.Padrao =  'LAVOURA'
               
    
    
    def handleCheckboxStateChangeAbertura(self):
        
        if self.dlg.radioButtonAbertura.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
           
            self.dlg.groupBoxAbertura.setEnabled(True)
        else:
            self.dlg.groupBoxAbertura.setEnabled(False)
    
    def handleCheckboxStateEstratificar(self):

        if self.dlg.checkBoxVerde.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
           
            self.dlg.spinBoxLavouraVerde.setEnabled(True)
        else:
            self.dlg.spinBoxLavouraVerde.setEnabled(False)


        if self.dlg.checkBoxVermelho.isChecked() == True:
            #bloco será executado somente se o QCheckBox estiver marcado
               
            self.dlg.spinBoxLavouraVermelho.setEnabled(True)
        else:
            self.dlg.spinBoxLavouraVermelho.setEnabled(False)
                
        if self.dlg.checkBoxAviao.isChecked() == True:
            #bloco será executado somente se o QCheckBox estiver marcado
               
            self.dlg.spinBoxLavouraAviao.setEnabled(True)
        else:
            self.dlg.spinBoxLavouraAviao.setEnabled(False)        
    
    # def executar_script(self):
        # from qgis.utils import iface
        # from qgis.PyQt.QtWidgets import QAction, QToolBar
    
        # if self.dlg.checkBoxContador.isChecked() == True:
            # exec(open('Z:/PyQGIS/grid/ContagemBandeiras.py').read())
        # else:
            # toolbar_widget = self.dlg.toolBarWidget  # Replace 'toolBarWidget' with the actual name of the toolbar widget
            # iface.removeToolBarWidget(toolbar_widget)
            
    # def executar_script(self):
        # from qgis.utils import iface
        # from qgis.PyQt.QtWidgets import QAction, QToolBar

        # if self.dlg.checkBoxContador.isChecked():
            # exec(open('Z:/PyQGIS/grid/ContagemBandeiras.py').read())


              
                
    
    
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GerarGridDialog()

        # show the dialog
        self.dlg.show()
        
        # Excecução funções Grade
        self.carregaVetor()
        self.dlg.buttonentrada.clicked.connect(self.abrirVetor)
        self.dlg.gerargrid.clicked.connect(self.gerargrade)
        
        # Excecução funções Estratificar
        self.dlg.radioButtonLavoura.toggled.connect(self.handleCheckboxStateChangeLavoura)
        self.dlg.radioButtonAbertura.toggled.connect(self.handleCheckboxStateChangeAbertura)
        self.dlg.radioButtonLavoura.toggled.connect(self.handleCheckboxStateChangeAberturaLavoura)
        self.dlg.radioButtonAbertura.toggled.connect(self.handleCheckboxStateChangeAberturaLavoura)
        
        # self.dlg.checkBoxContador.stateChanged.connect(self.executar_script)
        self.dlg.checkBoxVerde.stateChanged.connect(self.handleCheckboxStateEstratificar)
        self.dlg.checkBoxVermelho.stateChanged.connect(self.handleCheckboxStateEstratificar)
        self.dlg.checkBoxAviao.stateChanged.connect(self.handleCheckboxStateEstratificar)
        self.dlg.exportar.clicked.connect(self.exportarShp)
        self.dlg.pushButtonClassificar.clicked.connect(self.FarmClassificar)
        self.dlg.pushButtonEstratificar.clicked.connect(self.PontosEstratificar)
        
        
       
        # Run the dialog event loop
        result = self.dlg.exec_()
        self.dlg.buttonentrada.clicked.disconnect(self.abrirVetor)
        self.dlg.gerargrid.clicked.disconnect(self.gerargrade)
        self.dlg.exportar.clicked.disconnect(self.exportarShp)
        self.dlg.pushButtonClassificar.clicked.disconnect(self.FarmClassificar)
        self.dlg.pushButtonEstratificar.clicked.disconnect(self.PontosEstratificar)
        

        
        
        
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
          
            
            
            
    
            
    def gerargrade(self): 
        self.variaveis() 
        self.selected_layer_classificar = self.dlg.mMapLayerComboBoxFarm.currentLayer()
             
        from qgis.core import QgsProcessing
        from qgis.core import QgsProcessingAlgorithm
        from qgis.core import QgsProcessingMultiStepFeedback
        from qgis.core import QgsProcessingParameterVectorLayer
        import processing
        import os # This is is needed in the pyqgis console also
        from qgis.core import (QgsVectorLayer)
        import math

        path_co = self.entrada
        




        def projecaoInicial(path_co):
            geometry_layer = QgsVectorLayer(path_co, "FARM", "ogr")
        
            inicial = processing.run('native:assignprojection',{
            'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
            'INPUT': geometry_layer,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_projecao = inicial['OUTPUT']
            
            return  output_projecao
            
        geometry_layer = projecaoInicial(path_co)
    


        def __get_extension__(geometria): 
            
            
            
            extensao=processing.run('native:polygonfromlayerextent',{
            'INPUT': geometria,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'ROUND_TO': 0,
            })
            extensao_output = extensao['OUTPUT']
            geometry_grid = extensao_output.getFeature(1)
            x_min =  geometry_grid['MINX']
            y_min =  geometry_grid['MINY']
            x_max =  geometry_grid['MAXX']
            y_max =  geometry_grid['MAXY']
            
            
            return x_min, y_min, x_max, y_max
        x_min, y_min, x_max, y_max =__get_extension__(geometry_layer)    


        def __utm__(x_min, y_min, x_max, y_max):
            from pyproj import CRS
            from pyproj.aoi import AreaOfInterest
            from pyproj.database import query_utm_crs_info

            utm_crs_list = query_utm_crs_info(
                datum_name="SIRGAS 2000",
                area_of_interest=AreaOfInterest(
                    west_lon_degree=x_min,
                    south_lat_degree=y_min,
                    east_lon_degree=x_max,
                    north_lat_degree=y_max,
                ),
            )
            utm_crs = CRS.from_epsg(utm_crs_list[0].code)
            return utm_crs
        EPSG_crs = __utm__(x_min, y_min, x_max, y_max)
        EPSG = str(EPSG_crs)



        def __definindo_projecao__(geometry_layer, epsg_destino):
            reprojetar= processing.run('native:reprojectlayer', 
            {
            'INPUT': geometry_layer,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem(epsg_destino),
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_destino = reprojetar['OUTPUT']
            

            return output_destino
            
        geometry_layer=__definindo_projecao__(geometry_layer, EPSG)



        def __google_satelite_():
            import requests
            from qgis.utils import iface
            service_url = "mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}" 
            service_uri = "type=xyz&zmin=0&zmax=21&url=https://"+requests.utils.quote(service_url)
            tms_layer = iface.addRasterLayer(service_uri, "Google Sat", "wms")
            iface.setActiveLayer(tms_layer)
            iface.zoomToActiveLayer()
            vLayer = iface.activeLayer()
            canvas = iface.mapCanvas()
            extent = vLayer.extent()
            canvas.setExtent(extent)
            canvas.refresh()
        try:
            __google_satelite_()
        except:
            pass
            

        def __gerar_id__(ponto, numero_inicial = int):
            numero = str(numero_inicial)
            formula = 'array_find(array_reverse(array_sort(array_agg(to_string(to_int($x))+\'|\'+ to_string(to_int($y))))), to_string(to_int($x))+\'|\'+ to_string(to_int($y)))+'
            formula_final = formula + numero 
            id=processing.run('native:fieldcalculator',{
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'ID',
            'FIELD_PRECISION': 0,
            'FIELD_TYPE': 1,
            'FORMULA': formula_final,
            'INPUT': ponto,
            'OUTPUT': 'TEMPORARY_OUTPUT'

            })
            id_output = id['OUTPUT']

           

            return id_output


        def __load_farm__(geometry_layer):
            ## CALL GEOMETRY IN CANVAS
            #geometry_layer = QgsVectorLayer(geometry_utm, "FARM", "ogr")
            if not geometry_layer.isValid():
                print("Layer failed to load!")
            else:
                geometry_layer_id = processing.run('native:fieldcalculator',{
                'FIELD_LENGTH': 0,
                'FIELD_NAME': 'GEOMETRIA',
                'FIELD_PRECISION': 0,
                'FIELD_TYPE': 1,
                'FORMULA': '$id + 1',
                'INPUT': geometry_layer,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                geometry_layer_output = geometry_layer_id['OUTPUT']
                #QgsProject.instance().addMapLayer(geometry_layer) 
                
                numero_pontos1=processing.run('native:fieldcalculator',{
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'PONTOS',
                'FIELD_PRECISION': 2,
                'FIELD_TYPE': 1,
                'FORMULA': '\"HECTARES\"/\"GRID\"',
                'INPUT': geometry_layer_output,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                
                geometry_layer1 = numero_pontos1['OUTPUT']
                geometry_layer1.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_contorno.qml'))
                geometry_layer1.triggerRepaint()
                QgsProject.instance().addMapLayer(geometry_layer1)
                name=QgsProject.instance().mapLayersByName("Calculado")[0] 
                
                name.setName("FARM")
               
            return geometry_layer1    
         
        geometry_layer = __load_farm__(geometry_layer)



        def __dividir_camada_vetorial__(geometry):

            split_grid = processing.runAndLoadResults('native:splitvectorlayer',{
            'FIELD': 'GEOMETRIA',
            'FILE_TYPE': 1,
            'INPUT': geometry,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            })

            output_split_grid = split_grid['OUTPUT']
            return output_split_grid

        output_split_grid =__dividir_camada_vetorial__(geometry = geometry_layer)

        def __carregando_somente_shp__(output):
            list_geometry = []
            for files in os.listdir(output):

                # load only the shapefiles
                if files.endswith(".shp"):

                    # create vector layer object
                    vlayer = QgsVectorLayer(output + "/" + files, files, "ogr")
                    #QgsProject.instance().addMapLayer(vlayer)
                    list_geometry.append(vlayer)
            return list_geometry

        list_geometry =__carregando_somente_shp__(output_split_grid) 

         
        output_buffer_list = []
        def __tolerancia_borda__(tolerancia = int):
            for g in list_geometry:
                ## BUFFER PARA EVITAR BORDAS
                buffer= processing.run('native:buffer',{
                'DISSOLVE': False,
                'DISTANCE': tolerancia*-1,
                'END_CAP_STYLE': 0,
                'INPUT':g,
                'JOIN_STYLE': 0,
                'MITER_LIMIT': 2,
                'SEGMENTS': 5,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_buffer = buffer['OUTPUT']
                #QgsProject.instance().addMapLayer(output_buffer)
                output_buffer_list.append(output_buffer)
            
            return output_buffer_list
        output_buffer_list = __tolerancia_borda__(tolerancia = self.largura)

        def __mesclando_buffers__(output_buffer_list):
            ## MESCLANDO BUFFERS
            buffer_mesclado=processing.run('native:mergevectorlayers',{
            'CRS': None,
            'LAYERS':output_buffer_list ,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_buffer_mesclado = buffer_mesclado['OUTPUT']
            #QgsProject.instance().addMapLayer(output_buffer_mesclado)
            return output_buffer_mesclado
        try:
            output_buffer_mesclado=__mesclando_buffers__(output_buffer_list)  
        except:
            pass
            

        def __gerar_grid_diamante__(output_buffer_list):
            list_grid = []
            list_contagem=[]
            for b in output_buffer_list:
                try:
                    geometry_grid = b.getFeature(1) # pecorre cada  geometria com buffer e pegar o valor do grid
                    
                    ## Create Grid Diamond
                    ext = b.extent()
                    projection = geometry_layer.crs()
                    grid = geometry_grid['GRID']
                    seno = math.sqrt(2)/2
                    dist_xy = (math.sqrt(grid*10000)) / seno # expressão seno = cateto oposto/ hipotenusa

                    grid_diamond = processing.run('native:creategrid',{
                    'CRS': projection,
                    'EXTENT': ext,
                    'HOVERLAY': 0,
                    'HSPACING': dist_xy,
                    'TYPE': 3,
                    'VOVERLAY': 0,
                    'VSPACING': dist_xy,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })

                    output_grid = grid_diamond['OUTPUT']
                    #QgsProject.instance().addMapLayer(output_grid)
                    
                    vertices = processing.run('native:extractvertices',{
                    'INPUT':output_grid ,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    output_vertices = vertices['OUTPUT']
                    #QgsProject.instance().addMapLayer(output_vertices)
                    
                    recorte = processing.run('native:clip',{
                    'INPUT': output_vertices,
                    'OUTPUT': 'TEMPORARY_OUTPUT',
                    'OVERLAY': b
                    })

                    output_recorte = recorte['OUTPUT']
                    #QgsProject.instance().addMapLayer(output_recorte)
                    
                    
                    
                    amostragem1 = processing.run('native:deleteduplicategeometries',{
                    'INPUT': output_recorte,
                    'OUTPUT': 'TEMPORARY_OUTPUT'})
                    output_amostragem = amostragem1['OUTPUT']
                    #QgsProject.instance().addMapLayer(output_amostragem) 
                  

                    #QgsProject.instance().addMapLayer(output_amostragem)  
                    
                    contagem=processing.run('native:countpointsinpolygon',{
                    'CLASSFIELD': '',
                    'FIELD': 'NUMPOINTS',
                    'POINTS': output_amostragem,
                    'POLYGONS': b,
                    'WEIGHT': '',
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    
                    output_contagem = contagem['OUTPUT']
                    #QgsProject.instance().addMapLayer(output_contagem)
                    
                    list_grid.append(output_amostragem)
                    list_contagem.append(output_contagem)
                    
                except:
                    pass
            return list_grid, list_contagem, geometry_grid

        list_grid, list_contagem, geometry_grid  =__gerar_grid_diamante__(output_buffer_list)
            
        def __buffer_selecao__central(list_geometry, relacao = int):
            buffer_distxy_list = []
            for g in list_geometry:
                grid = geometry_grid['GRID']
                seno = math.sqrt(2)/2
                dist_xy = ((math.sqrt(grid*10000)) / seno)/relacao
                buffer = dist_xy
                ## BUFFER PARA EVITAR BORDAS
                buffer_distxy= processing.run('native:buffer',{
                'DISSOLVE': False,
                'DISTANCE': buffer*-1,
                'END_CAP_STYLE': 0,
                'INPUT':g,
                'JOIN_STYLE': 0,
                'MITER_LIMIT': 2,
                'SEGMENTS': 5,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_buffer_distxy = buffer_distxy['OUTPUT']
                buffer_distxy_list.append(output_buffer_distxy)
                
            return buffer_distxy_list    
        output_buffer_distxy =__buffer_selecao__central(list_geometry, relacao = 2)

        output_buffer_mesclado_distxy = __mesclando_buffers__(output_buffer_distxy)
        ##QgsProject.instance().addMapLayer(output_buffer_mesclado_distxy)
        #
        output_pontos_mesclado = __mesclando_buffers__(list_grid)
        ##QgsProject.instance().addMapLayer(output_pontos_mesclado)
        output_contagem_mesclado=__mesclando_buffers__(list_contagem)
        ##QgsProject.instance().addMapLayer(output_pontos_mesclado)



        def __associacao_atributos__(input, join):
            associacao_atributos = processing.run('native:joinattributesbylocation',{
            'DISCARD_NONMATCHING': False,
            'INPUT': input,
            'JOIN': join,
            'JOIN_FIELDS': [''],
            'METHOD': 0,
            'NON_MATCHING': None,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'PREDICATE': [0,1,4,5],
            'PREFIX': ''
            })

            output_associacao = associacao_atributos['OUTPUT']
            return output_associacao
        output_associacao=__associacao_atributos__(output_pontos_mesclado, output_contagem_mesclado)
            
        def __calculando_campo_relacao__(input, formula =str):    
            numero_pontos=processing.run('native:fieldcalculator',{
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'RELACAO',
            'FIELD_PRECISION': 2,
            'FIELD_TYPE': 1,
            'FORMULA': formula,
            'INPUT': input,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })

            output_pontos_calculado = numero_pontos['OUTPUT']
            #QgsProject.instance().addMapLayer(output_pontos_calculado)
            
            
            multi_to_simples=processing.run('native:multiparttosingleparts',
            {
            'INPUT': output_pontos_calculado,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            })
            output_pontos_calculado_simples = multi_to_simples['OUTPUT']
            return output_pontos_calculado_simples
        output_pontos_calculado_simples = __calculando_campo_relacao__(output_associacao, formula ='\"PONTOS\"-\"NUMPOINTS\"')
        #QgsProject.instance().addMapLayer(output_pontos_calculado_simples)    
           

        def __adicionar_xy__(output_pontos_calculado_simples, EPSG = str):
            pontos_x_y=processing.run('native:addxyfields', {
            'CRS': QgsCoordinateReferenceSystem(EPSG),
            'INPUT': output_pontos_calculado_simples,
            'PREFIX': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'})

            output_pontos_x_y = pontos_x_y['OUTPUT']
           
            return output_pontos_x_y
            
        output_pontos_x_y = __adicionar_xy__(output_pontos_calculado_simples, EPSG = EPSG)

        ## EXTRAINDO PONTOS MAIS CENTRAIS

        def __extrair_pontos_centrais__(input, intersect):
            extrair_localizacao=processing.run('native:extractbylocation',
            {
            'INPUT':input ,
            'INTERSECT':intersect ,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'PREDICATE': [0,1,5,6],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            })
            output_extrair_localizacao = extrair_localizacao['OUTPUT']
            
            dissolvido=processing.run('native:dissolve',{
            'FIELD': ['GEOMETRIA'],
            'INPUT': output_extrair_localizacao,
            'OUTPUT': 'TEMPORARY_OUTPUT',

            })
            output_dissolvido = dissolvido['OUTPUT']
            
            return output_extrair_localizacao,output_dissolvido 
        output_extrair_localizacao, output_dissolvido =__extrair_pontos_centrais__(output_pontos_x_y, output_buffer_mesclado_distxy)    


        output_split_localizacao=__dividir_camada_vetorial__(output_extrair_localizacao)
        list_localizacao =__carregando_somente_shp__(output_split_localizacao) 


        def __adicionando_pontos_faltantes__(list_localizacao, EPSG = str):
            output_pontos_x_y = __adicionar_xy__(output_pontos_calculado_simples, EPSG = EPSG)
            selecao_list = []
            extracao_list = []
            for i in list_localizacao:
                try:
                    for feature in i.getFeatures():
                        relacao = feature["RELACAO"]
                        #print(relacao)
                        geometrias = feature["GEOMETRIA"]
                        grid = feature["GRID"]
                        seno = math.sqrt(2)/2
                        dist_x = ((math.sqrt(grid*10000)) / seno)/2
                        
                        

                    if relacao >0:
                        #print(relacao)
                        #FAZENDO SELEÇÃO ALEATORIA CONFORME A QUANTIDADE DE PONTOS FALTANTE
                        selecao_aleatoria=processing.run('qgis:randomselection',{
                        'INPUT': i,
                        'METHOD': 0,
                        'NUMBER': relacao
                        
                        })

                        output_aleatorio = selecao_aleatoria['OUTPUT']
                        #QgsProject.instance().addMapLayer(output_aleatorio)
                   
                        #EXTRAINDO ATRIBUTOS
                        
                        extrair_selecionado=processing.run('native:saveselectedfeatures', 
                        {
                        'INPUT': output_aleatorio,
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                        })
                        output_extracao = extrair_selecionado['OUTPUT']
                    
                        #CALCULANDO DISTX PARA CADA PONTO, PARA INSERIR POSTORIAMENTE
                        
                        new_distx=processing.run('native:fieldcalculator',{
                        'FIELD_LENGTH': 50,
                        'FIELD_NAME': 'DIST_X',
                        'FIELD_PRECISION': 10,
                        'FIELD_TYPE': 0,
                        'FORMULA':dist_x ,
                        'INPUT': output_extracao,
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                        })
                        output_new_calculado = new_distx['OUTPUT']
                        
                        new_point=processing.run('native:fieldcalculator',{
                        'FIELD_LENGTH': 50,
                        'FIELD_NAME': 'NEW_X',
                        'FIELD_PRECISION': 10,
                        'FIELD_TYPE': 0,
                        'FORMULA': '\"X\"+\"DIST_X\"',
                        'INPUT': output_new_calculado,
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                        })
                        output_new_calculado1 = new_point['OUTPUT']
                
                        extracao_list.append(output_new_calculado1)
                except:
                    pass
            try:   
                extracao_mesclado=processing.run('native:mergevectorlayers',{
                'CRS': None,
                'LAYERS':extracao_list ,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_extracao_mesclado = extracao_mesclado['OUTPUT']
            except:
                pass
            
            try:
                add_point=processing.run('native:createpointslayerfromtable',{
                'INPUT': output_extracao_mesclado,
                'MFIELD': '',
                'TARGET_CRS': EPSG,
                'XFIELD': 'NEW_X',
                'YFIELD': 'Y',
                'ZFIELD': '',
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_pontos_add = add_point['OUTPUT']
            except:
                pass
                
            ##MESCLANDO VETORES LAYER(PONTOS ADD) E PONTOS ORIGINAIS
            try:
                list_merge_1 = [output_pontos_x_y, output_pontos_add]
                pontos_primeira_varredura=processing.run('native:mergevectorlayers',{
                'CRS': None,
                'LAYERS':list_merge_1,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_primeira_varredura = pontos_primeira_varredura['OUTPUT']
            
                return output_primeira_varredura
            except:
                pass
            return output_pontos_x_y        
        
      
        output_primeira_varredura = __adicionando_pontos_faltantes__(list_localizacao, EPSG = EPSG )
        
            

        def __pontos_faltantes__(output_primeira_varredura, geometry):

            contagem=processing.run('native:countpointsinpolygon',{
            'CLASSFIELD': '',
            'FIELD': 'NUMPOINTS',
            'POINTS': output_primeira_varredura,
            'POLYGONS': geometry,
            'WEIGHT': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })

            output_contagem = contagem['OUTPUT']
            output_segunda_varredura=__calculando_campo_relacao__(output_contagem, formula ='\"PONTOS\"-\"NUMPOINTS\"')
            
            geometria_faltante= processing.run('native:extractbyexpression',
            {
            'EXPRESSION': '\"RELACAO\">0',
            'INPUT': output_segunda_varredura,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            
            
            output_geometria_faltante = geometria_faltante['OUTPUT']
            #QgsProject.instance().addMapLayer(output_geometria_faltante)
            
            output_split_grid =__dividir_camada_vetorial__(geometry = output_geometria_faltante)
            list_geometry =__carregando_somente_shp__(output_split_grid) 


            
            list_pontos_aleatorio = []
            for i in list_geometry:
                
                for feature in i.getFeatures():
                    relacao = feature["RELACAO"]
                    
                    geometrias = feature["GEOMETRIA"]
                    grid = feature["GRID"]
                    seno = math.sqrt(2)/2
                    dist_x = ((math.sqrt(grid*10000)) / seno)/2
            
                
                pontos_faltantes = processing.run('qgis:randompointsinsidepolygons',{
                'INPUT': i,
                'MIN_DISTANCE': dist_x,
                'OUTPUT': 'TEMPORARY_OUTPUT',
                'STRATEGY': 0,
                'VALUE': relacao,
                })
                output_pontos_faltante = pontos_faltantes['OUTPUT']
                #QgsProject.instance().addMapLayer(output_pontos_faltante)
                list_pontos_aleatorio.append(output_pontos_faltante)
            output_pontos_faltante=__mesclando_buffers__(list_pontos_aleatorio)
            
            
            new_point=processing.run('native:fieldcalculator',{
            'FIELD_LENGTH': 100,
            'FIELD_NAME': 'CATEGORIA',
            'FIELD_PRECISION': 10,
            'FIELD_TYPE': 2,
            'FORMULA': '\'ADICIONADO ALEATORIAMENTE\'',
            'INPUT': output_pontos_faltante,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_new_calculado_categoria = new_point['OUTPUT']

            
            
            
            list = [output_new_calculado_categoria,output_primeira_varredura]
            mesclado=processing.run('native:mergevectorlayers',{
            'CRS': None,
            'LAYERS': list,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_mesclado = mesclado['OUTPUT']
            
            output_mesclado.loadNamedStyle(os.path.join(self.plugin_dir,'pontos_aleatorio.qml'))
            output_mesclado.triggerRepaint()
            QgsProject.instance().addMapLayer(output_mesclado)
            old_name=QgsProject.instance().mapLayersByName("Mesclado")[0] 
            old_name.setName("GRADE DE PONTOS")
            
            return output_mesclado
        try:
            output_primeira_varredura=__pontos_faltantes__(output_primeira_varredura, geometry_layer)
        except:
            pass
            
            new_point=processing.run('native:fieldcalculator',{
            'FIELD_LENGTH': 100,
            'FIELD_NAME': 'CATEGORIA',
            'FIELD_PRECISION': 10,
            'FIELD_TYPE': 2,
            'FORMULA': '\'\'',
            'INPUT': output_primeira_varredura,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_new_calculado_categoria = new_point['OUTPUT']
            
            output_new_calculado_categoria.loadNamedStyle(os.path.join(self.plugin_dir,'pontos_aleatorio.qml'))
            output_new_calculado_categoria.triggerRepaint()
            QgsProject.instance().addMapLayer(output_new_calculado_categoria)
            old_name=QgsProject.instance().mapLayersByName("Calculado")[0] 
            old_name.setName("GRADE DE PONTOS")
            

        def __geometria_sem_ponto__(input, intersect):
            #RELACAO DE GEOMETRIA SEM PONTOS
            sem_pontos= processing.run('native:selectbylocation',{
            'INPUT': input,
            'INTERSECT':intersect ,
            'METHOD': 0,
            'PREDICATE': [2],
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_sem_pontos= sem_pontos['OUTPUT']
            AreaLayer = QgsProject.instance().mapLayersByName("FARM")[0]
            if AreaLayer.selectedFeatureCount()>0:
                resposta_sem_pontos = 'O polígono possui geometria sem ponto'
                print(resposta_sem_pontos)
            else:
                resposta_sem_pontos = 'O Grid de pontos foi gerado corretamente'
            
            return output_sem_pontos, AreaLayer 
        output_sem_pontos, AreaLayer =__geometria_sem_ponto__(geometry_layer, output_primeira_varredura)

        resposta = 'sim'
        def __gerar_centroide__(resposta, AreaLayer, output_primeira_varredura):
            try:
                if AreaLayer.selectedFeatureCount()>0 and resposta =='sim':
                    #EXTRAINDO ATRIBUTOS
                    
                    extrair_geometria_selecionada=processing.run('native:saveselectedfeatures', 
                    {
                    'INPUT': AreaLayer,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    output_geometria_selecionada = extrair_geometria_selecionada['OUTPUT']
                    
                    
                    
                    inserir_centroide=processing.run('native:centroids',
                    {
                    'ALL_PARTS': False,
                    'INPUT':output_geometria_selecionada ,
                    'OUTPUT': 'TEMPORARY_OUTPUT',
                    })
                    output_centroide= inserir_centroide['OUTPUT']
                    
                    ###MESCLANDO VETORES LAYER(PONTOS ADD) E PONTOS ORIGINAIS
                    list_merge_2 = [output_centroide, output_primeira_varredura]
                    pontos_segunda_varredura=processing.run('native:mergevectorlayers',{
                    'CRS': None,
                    'LAYERS':list_merge_2,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    output_segunda_varredura = pontos_segunda_varredura['OUTPUT']
                    
                    output_segunda_varredura =__gerar_id__(output_segunda_varredura, numero_inicial = 250)
                    output_segunda_varredura.loadNamedStyle(os.path.join(self.plugin_dir,'pontos_aleatorio.qml'))
                    output_segunda_varredura.triggerRepaint()
                    QgsProject.instance().addMapLayer(output_segunda_varredura)
                    old_name=QgsProject.instance().mapLayersByName("Calculado")[0] 
                    old_name.setName("GRADE DE PONTOS COM CENTROIDES")
                return output_segunda_varredura
                
            except:
                return print('Nao foi possivel realizar a operacao')

        

        def __count_point__(farm, name_layer_point):
            
            layer_point = QgsProject.instance().mapLayersByName(name_layer_point)[0]
            layer_farm = QgsProject.instance().mapLayersByName(farm)[0]
            total_sum = layer_farm.aggregate(QgsAggregateCalculator.Sum, "PONTOS")

            feature_count_centroide = layer_point.featureCount()
            
            relacao_points_excedentes = feature_count_centroide - total_sum[0]
            relacao_points_excedentes_int = int(relacao_points_excedentes)

            return relacao_points_excedentes_int



        def __remover__(name_layer_point, number_remove):
            import random
            layer = QgsProject.instance().mapLayersByName(name_layer_point)[0]
            expression = QgsExpression("CATEGORIA = 'ADICIONADO ALEATORIAMENTE'")
            selected_features = layer.getFeatures(QgsFeatureRequest(expression))
            selected_feature_ids = [f.id() for f in selected_features]
            random.seed(0) # set a seed for reproducibility
            random_feature_ids = random.sample(selected_feature_ids, number_remove )
            layer.startEditing()
            layer.deleteFeatures(random_feature_ids)
            layer.commitChanges()
           
        def __relacao_centroide__():
            try:
                output_segunda_varredura=__gerar_centroide__('sim', AreaLayer, output_primeira_varredura)
                relacao_centroide=__count_point__("FARM", "GRADE DE PONTOS COM CENTROIDES")
                if relacao_centroide > 0:
                    __remover__("GRADE DE PONTOS COM CENTROIDES",relacao_centroide)
            except:
                pass
        self.dlg.geraramostras.clicked.connect(__relacao_centroide__)
        #__relacao_centroide__()


        def __relacao_grade_pontos__():
            try:
                relacao_pontos=__count_point__("FARM", "GRADE DE PONTOS")
                if relacao_pontos > 0:
                    __remover__("GRADE DE PONTOS",relacao_pontos)
            except:
                pass



        __relacao_grade_pontos__()
                 
            
    
    def FarmClassificar(self):
    
        from qgis.core import QgsProcessing
        from qgis.core import QgsProcessingAlgorithm
        from qgis.core import QgsProcessingMultiStepFeedback
        from qgis.core import QgsProcessingParameterVectorLayer
        import processing
        import os # This is is needed in the pyqgis console also
        from qgis.core import (QgsVectorLayer)
        import math
        import qgis.core
        from PyQt5.QtCore import QSettings, QVariant 

        self.ClassificarFarm
   
        self.selected_layer_classificar = self.dlg.mMapLayerComboBoxFarm.currentLayer()
        # get the original layer
        original_layer = self.selected_layer_classificar
        
        
       
        # create a new layer based on the original layer's data source
        new_layer = QgsVectorLayer(original_layer.source(), 'FARM CLASSIFICADO', original_layer.providerType())
        new_layer.setName('FARM CLASSIFICADO')
    
        # set the selection on the new layer to be the same as the original layer
        new_layer.selectByIds(original_layer.selectedFeatureIds()) 

        if self.dlg.radioButtonAbertura.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
            self.Padrao =  'ABERTURA'
        
        if self.dlg.radioButtonLavoura.isChecked() == True:
            self.Padrao =  'LAVOURA'
            
        
        def __remover_padrao__(layer):
            layer.reload()
            # find the index of the 'PADRÃO' field
            field_index = layer.fields().indexFromName('PADRAO')

            # remove the field by index
            layer.dataProvider().deleteAttributes([field_index])

            # update the layer to reflect the changes
            layer.updateFields()
            
            
        def __criando_padrao__():
            ''' CRIA CAMPO PADRAO 
                entrada: geometry_layer 
                return: 
            '''
            copy_layer_farm = new_layer
            pr = copy_layer_farm.dataProvider()
            
            # Define the fields to add
            fields_to_add = [
            QgsField("PADRAO", QVariant.String, 'string', 40)]
            
            # Get the existing field names
            existing_field_names = [field.name() for field in copy_layer_farm.fields()]

            # Add only the fields that don't already exist
            for field in fields_to_add:
                if field.name() not in existing_field_names:
                    pr.addAttributes([field])
                    existing_field_names.append(field.name())

            # Update layer to propagate changes to the map
            copy_layer_farm.updateFields()


        def __classificando_padrao__(selection_only=False):
            ''' MODIFICA VALORES DO CAMPO SELECIONADO PARA LAVOURA
                entrada: geometry_layer 
                return: 
            '''
            layer = new_layer
            field_name = "PADRAO"
            new_value = 'LAVOURA'
            layer.startEditing()
            if selection_only:
                features = layer.selectedFeatures()
            else:
                features = layer.getFeatures()
            for feature in features:
                field_index = layer.fields().indexFromName(field_name)
                layer.changeAttributeValue(feature.id(), field_index, new_value)
            layer.commitChanges()


        def __classificando_abertura__():
            ''' MODIFICA VALORES DO CAMPO  NÃO SELECIONADO PARA ABERTURA
                entrada: geometry_layer 
                return: 
            '''
            layer = new_layer
            
            
            field_name = "PADRAO"  # specify the name of the field to update
            new_value = 'ABERTURA'  # specify the value to add to the empty fields

            # loop through each feature and update the field if it is empty
            with edit(layer):
                for feature in layer.getFeatures():
                    if feature[field_name] == NULL:
                        feature[field_name] = new_value
                        layer.updateFeature(feature)
            #QgsProject.instance().addMapLayer(layer)
            

        def __legenda_inicial_farm__():
            ''' CARREGAR LEGENDA
                entrada: geometry_layer 
                return: 
            '''
            layer = QgsProject.instance().mapLayersByName("FARM CLASSIFICADO")[0]
            layer.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_contorno_padrao.qml'))
            layer.triggerRepaint()
            return layer

        

        def __etapa_farm__():
            ''' CHAMA TODAS AS FUNÇÕES RELACIONADA A FARM
                entrada: geometry_layer 
                return: geometry_layer 
            '''
            __criando_padrao__()
            __classificando_padrao__(selection_only=True)
            __classificando_abertura__()
            
           
            
       
        __etapa_farm__()
        
        
        def __projecao_inicial__(layer): 
                projecao_inicial= processing.run('native:assignprojection', {
                'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                'INPUT': layer,
                'OUTPUT': 'TEMPORARY_OUTPUT'

                })
                projecao_output = projecao_inicial['OUTPUT']
                return projecao_output
            
        copy_layer_farm=__projecao_inicial__(new_layer)
        copy_layer=__projecao_inicial__(new_layer)
   
        
        def __get_extension__(geometria): 
            ''' PEGA LIMITES DA GEOMETRIA
                entrada: geometria -> layer qgis projeção em 4326
                return: x_min, y_min, x_max, y_max
            '''
        
        
            extensao=processing.run('native:polygonfromlayerextent',{
            'INPUT': geometria,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'ROUND_TO': 0,
            })
            extensao_output = extensao['OUTPUT']
            geometry_grid = extensao_output.getFeature(1)
            x_min =  geometry_grid['MINX']
            y_min =  geometry_grid['MINY']
            x_max =  geometry_grid['MAXX']
            y_max =  geometry_grid['MAXY']
        
            return x_min, y_min, x_max, y_max
        x_min, y_min, x_max, y_max =__get_extension__(copy_layer_farm)    

        def __utm__(x_min, y_min, x_max, y_max):
            ''' DEFINE PROJECAO DOS LIMITES
                entrada: x_min, y_min, x_max, y_max
                return: EPSG -> str
            '''
            from pyproj import CRS
            from pyproj.aoi import AreaOfInterest
            from pyproj.database import query_utm_crs_info

            utm_crs_list = query_utm_crs_info(
                datum_name="SIRGAS 2000",
                area_of_interest=AreaOfInterest(
                    west_lon_degree=x_min,
                    south_lat_degree=y_min,
                    east_lon_degree=x_max,
                    north_lat_degree=y_max,
                ),
            )
            utm_crs = CRS.from_epsg(utm_crs_list[0].code)
            EPSG = str(utm_crs)
            return EPSG
            
        EPSG = __utm__(x_min, y_min, x_max, y_max)

        def __definindo_projecao__(geometry_layer, epsg_destino):
            ''' REPROJETA LAYER PARA UTM DESTINO
                entrada: geometria -> geometry_layer, epsg_destino
                return: Reprojetado
            '''
            reprojetar= processing.run('native:reprojectlayer', 
            {
            'INPUT': geometry_layer,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem(epsg_destino),
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_destino = reprojetar['OUTPUT']
           
            #QgsProject.instance().addMapLayer(output_destino) 
            return output_destino
            
        geometry_layer1=__definindo_projecao__(copy_layer_farm, EPSG)



        def __load_farm__(geometry_layer):
            ''' CRIA CAMPO GEOMETRIA 
                entrada: geometry_layer e geometria_layer1
                return: Calculado e Reprojetado
            '''
            
            if not geometry_layer.isValid():
                print("Layer failed to load!")
            else:
                geometry_layer_id = processing.run('native:fieldcalculator',{
                'FIELD_LENGTH': 0,
                'FIELD_NAME': 'GEOMETRIA',
                'FIELD_PRECISION': 0,
                'FIELD_TYPE': 1,
                'FORMULA': '$id + 1',
                'INPUT': geometry_layer,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                geometry_layer_output = geometry_layer_id['OUTPUT']
                QgsProject.instance().addMapLayer(geometry_layer_output)
                old_name=QgsProject.instance().mapLayersByName("Calculado")[0] 
                old_name.setName("FARM CLASSIFICADO")
                
                
               
            return geometry_layer_output
         
        geometry_layer = __load_farm__(geometry_layer1)
        __legenda_inicial_farm__()
        __remover_padrao__(original_layer)
        
        
    def PontosEstratificar(self):
        from qgis.core import QgsProcessing
        from qgis.core import QgsProcessingAlgorithm
        from qgis.core import QgsProcessingMultiStepFeedback
        from qgis.core import QgsProcessingParameterVectorLayer
        import processing
        import os # This is is needed in the pyqgis console also
        from qgis.core import (QgsVectorLayer)
        import math
        import qgis.core
        from PyQt5.QtCore import QSettings, QVariant 
        #Chamando Funções
        self.AmostraEstratificar
        self.handleCheckboxStateChangeAberturaLavoura
        
        #chamando Variáveis
        self.valor_grade = self.dlg.spinBoxGrade.value()
        self.selected_layer_estratificar = self.dlg.mMapLayerComboBoxAmostra.currentLayer()
        
        if self.dlg.radioButtonAbertura.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
            self.Padrao =  'ABERTURA'
   
        if self.dlg.radioButtonLavoura.isChecked() == True:
            self.Padrao =  'LAVOURA'
        
        self.valor_verde = self.dlg.spinBoxLavouraVerde.value()
        self.valor_vermelho = self.dlg.spinBoxLavouraVermelho.value()
        self.valor_aviao = self.dlg.spinBoxLavouraAviao.value()
        
        
        farm = QgsProject.instance().mapLayersByName("FARM CLASSIFICADO")[0]
        
        def __associacao_atributos__(input, join):
            ''' CHAMA TODAS AS FUNÇÕES RELACIONADA A FARM
                entrada: geometry_layer 
                return: geometry_layer 
            '''
            associacao_atributos = processing.run('native:joinattributesbylocation',{
            'DISCARD_NONMATCHING': False,
            'INPUT': input,
            'JOIN': join,
            'JOIN_FIELDS': [''],
            'METHOD': 0,
            'NON_MATCHING': None,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'PREDICATE': [0,1,4,5],
            'PREFIX': ''
            })

            output_associacao = associacao_atributos['OUTPUT']
            #QgsProject.instance().addMapLayer(output_associacao)
            return output_associacao
     
        def __criando_campos__(copy_layer):
            ''' CRIA CAMPOS NECESSARIO GPX 
                entrada: copy_layer 
                return: 
            '''
            pr = copy_layer.dataProvider()

            # Define the fields to add
            fields_to_add = [
            QgsField("name", QVariant.String, 'string', 40),
            QgsField("cmt", QVariant.String, 'string', 40),
            QgsField("desc", QVariant.String, 'string', 40),
            QgsField("sym", QVariant.String, 'string', 40)]

            # Get the existing field names
            existing_field_names = [field.name() for field in copy_layer.fields()]

            # Add only the fields that don't already exist
            for field in fields_to_add:
                if field.name() not in existing_field_names:
                    pr.addAttributes([field])
                    existing_field_names.append(field.name())

            # Update layer to propagate changes to the map
            copy_layer.updateFields()
            
            return copy_layer


        def __copy_field__(layer):
            """
            Copies the values from the source field to the destination field in the specified layer.

            :param layer: the layer to copy values in
            :type layer: QgsVectorLayer
            """
            field_index = layer.fields().indexOf("ID")
            if field_index == -1:
                print(f"Field '{'ID'}' not found in layer")
                return

            name_index = layer.fields().indexOf("name")
            if name_index == -1:
                print(f"Field '{'name'}' not found in layer")
                return
                
            cmt_index = layer.fields().indexOf("cmt")
            if cmt_index == -1:
                print(f"Field '{'cmt'}' not found in layer")
                return

            desc_index = layer.fields().indexOf("desc")
            if desc_index == -1:
                print(f"Field '{'desc'}' not found in layer")
                return
            
                
            layer.startEditing()
            for feature in layer.getFeatures():
                value = feature.attribute("ID")
                layer.changeAttributeValue(feature.id(), name_index, value)
                layer.changeAttributeValue(feature.id(), cmt_index, value)
                layer.changeAttributeValue(feature.id(), desc_index, value)
            layer.commitChanges()
    

        def __estratificar_padrao__(pontos_farm):
            ''' ESTATRATIFICA DE ACORDO COM PADRAO LAVOURA/ABERTURA
                entrada: pontos_farm 
                return: 
            '''
            
            # Get a reference to the layer
            layer = pontos_farm


            # Define the field names
            field_name_to_check = 'PADRAO'  # field to check for specific value
            field_name_to_update = 'sym' # field to update with new value

            # Define the specific value to check for and the new value to assign
            value_to_check = 'LAVOURA'
            new_value = 'Waypoint'

            # Start an edit session for the layer
            layer.startEditing()

            # Loop through the features and update the value in Field2 if the condition is True
            for feature in layer.getFeatures():
                if feature[field_name_to_check] == value_to_check:
                    # Set the new value for the field
                    field_index = layer.fields().indexFromName(field_name_to_update)
                    feature[field_index] = new_value
                    # Update the feature in the layer
                    layer.updateFeature(feature)
                else:
                    # Set the new value for the field
                    field_index = layer.fields().indexFromName(field_name_to_update)
                    feature[field_index] = 'Flag, Blue'
                    # Update the feature in the layer
                    layer.updateFeature(feature)

             #Save the changes and exit the edit session
            layer.commitChanges()
            layer.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_gps13.qml'))
            layer.triggerRepaint()
            
            

        def __pontos_estratificar__():
            ''' CHAMAR TODAS AS FUNÇÕES
            '''
            pontos_farm=__associacao_atributos__(self.selected_layer_estratificar, farm)
            layer_gpx=__criando_campos__(pontos_farm)
            __copy_field__(pontos_farm)
            __estratificar_padrao__(pontos_farm)
            
            return pontos_farm
        pontos_farm=__pontos_estratificar__()    
        def __projecao_inicial__(layer): 
                projecao_inicial= processing.run('native:assignprojection', {
                'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                'INPUT': layer,
                'OUTPUT': 'TEMPORARY_OUTPUT'

                })
                projecao_output = projecao_inicial['OUTPUT']
                return projecao_output
            
        pontos_farm1=__projecao_inicial__(pontos_farm)
        
   
        
        def __get_extension__(geometria): 
            ''' PEGA LIMITES DA GEOMETRIA
                entrada: geometria -> layer qgis projeção em 4326
                return: x_min, y_min, x_max, y_max
            '''
        
        
            extensao=processing.run('native:polygonfromlayerextent',{
            'INPUT': geometria,
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'ROUND_TO': 0,
            })
            extensao_output = extensao['OUTPUT']
            geometry_grid = extensao_output.getFeature(1)
            x_min =  geometry_grid['MINX']
            y_min =  geometry_grid['MINY']
            x_max =  geometry_grid['MAXX']
            y_max =  geometry_grid['MAXY']
        
            return x_min, y_min, x_max, y_max
        x_min, y_min, x_max, y_max =__get_extension__(pontos_farm1)    

        def __utm__(x_min, y_min, x_max, y_max):
            ''' DEFINE PROJECAO DOS LIMITES
                entrada: x_min, y_min, x_max, y_max
                return: EPSG -> str
            '''
            from pyproj import CRS
            from pyproj.aoi import AreaOfInterest
            from pyproj.database import query_utm_crs_info

            utm_crs_list = query_utm_crs_info(
                datum_name="SIRGAS 2000",
                area_of_interest=AreaOfInterest(
                    west_lon_degree=x_min,
                    south_lat_degree=y_min,
                    east_lon_degree=x_max,
                    north_lat_degree=y_max,
                ),
            )
            utm_crs = CRS.from_epsg(utm_crs_list[0].code)
            EPSG = str(utm_crs)
            return EPSG
            
        EPSG = __utm__(x_min, y_min, x_max, y_max)

        def __definindo_projecao__(pontos_farm, epsg_destino):
            ''' REPROJETA LAYER PARA UTM DESTINO
                entrada: geometria -> geometry_layer, epsg_destino
                return: Reprojetado
            '''
            reprojetar= processing.run('native:reprojectlayer', 
            {
            'INPUT': pontos_farm,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem(epsg_destino),
            'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            output_destino = reprojetar['OUTPUT']
           
                       
            return output_destino
            
        geometry_layer1=__definindo_projecao__(pontos_farm, EPSG)    
        
        
        ### INICIO DO BLOCO DISTRIBUIR BANDEIRAR

        ## ARRUMA NOME DE SAIDA E CARREGAR LEGENDAS
        def __extrair_expressao__(pontos_farm, grid_value = int, padrao_value = str):
            ''' EXTRAI OS PONTOS CONFORME GRID E PADRAO, COM O INTUITO DE TRABALHAR
                SEPARADAMENTE CADA GEOMETRIA
                entrada: pontos_farm 
                return: Encontrando feições
            '''
            nome_padrao_point = 'AMOSTRAS '+ 'GRADE ' + str(grid_value) + ' ' + padrao_value
            expression = f"GRID = {grid_value} AND PADRAO = '{padrao_value}'"
            extrair = processing.run('native:extractbyexpression',
            {
                'EXPRESSION': expression,
                'INPUT': pontos_farm,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            extrair_output = extrair['OUTPUT']
            QgsProject.instance().addMapLayer(extrair_output)
            old_name=QgsProject.instance().mapLayersByName("Encontrando feições")[0] 
            old_name.setName(nome_padrao_point)
            return extrair_output, nome_padrao_point

                

        point_layer, nome_padrao_point=__extrair_expressao__(geometry_layer1, self.valor_grade, self.Padrao)



        def __dividir_camada_vetorial__():
            ''' DIVIDI CAMADA VETORIAL DA FAZENDA PELAS GEOMETRIA, SERVE PARA GERAR GRID
                entrada: geometry 
                return: 
            '''
            geometry = QgsProject.instance().mapLayersByName("FARM CLASSIFICADO")[0]

            split_grid = processing.runAndLoadResults('native:splitvectorlayer',{
            'FIELD': 'GEOMETRIA',
            'FILE_TYPE': 1,
            'INPUT': geometry,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            })

            output_split_grid = split_grid['OUTPUT']
            return output_split_grid

        output_split_grid =__dividir_camada_vetorial__()


        def __carregando_somente_shp__(output):
            ''' CARREGA SHP DE UMA PASTA TEMPORARIA
                entrada: output 
                return: 
            '''
            list_geometry = []
            for files in os.listdir(output):

                # load only the shapefiles
                if files.endswith(".shp"):

                    # create vector layer object
                    vlayer = QgsVectorLayer(output + "/" + files, files, "ogr")
                    #QgsProject.instance().addMapLayer(vlayer)
                    list_geometry.append(vlayer)
            return list_geometry

        list_geometry =__carregando_somente_shp__(output_split_grid) 


        def __corrigir__(list_layer):
            ''' CARRIGI GEOMETRIA, ALTERNATIVA PARA JOGAR SHP NA MEMORIA
                entrada: list_geometry 
                return: 
            '''
            list_geometria_corrigida = []
            for l in list_layer:
                corrigir= processing.run('native:fixgeometries',{
                'INPUT': l,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_corrigido = corrigir['OUTPUT']
                list_geometria_corrigida.append(output_corrigido)
            
            return list_geometria_corrigida
                
        list_geometria_corrigida=__corrigir__(list_geometry)


        def __gerar_grid_regular__(list_geometry, grid_value = int, padrao_value = str, porcentagem_value = int):
            list_grid = []
            geometry_layer = QgsProject.instance().mapLayersByName("FARM CLASSIFICADO")[0]
            
            
            for b in list_geometry:
                
                ext = b.extent()
                projection = geometry_layer.crs()
                geometry_grid = b.getFeature(1) # pecorre cada  geometria com buffer e pegar o valor do grid
                ## Filter by PADRAO field
                padrao = geometry_grid['PADRAO']
                if padrao != padrao_value:
                    continue
                
                grid = geometry_grid['GRID']
                if grid != grid_value:
                    continue
                grid = geometry_grid['GRID']
                ##
                
                porcentagem = porcentagem_value
                if porcentagem == 50:
                    multiplicador = 1.5
                
                if porcentagem == 25:
                    multiplicador = 2.3 
                
                if porcentagem == 20:
                    multiplicador = 2.6
                    
                if porcentagem == 15 :
                    multiplicador = 3.3
               
                if porcentagem == 10 :
                    multiplicador = 4.3
            
                if porcentagem == 5 :
                    multiplicador = 5.2
               
                if grid_value == 1:
                    dist_xy = (math.sqrt(grid*10000)) * multiplicador
                else:
                    dist_xy = (math.sqrt(grid*10000)) * (multiplicador  + float(grid_value/9))
                 
                
                try:
                    grid_diamond = processing.run('native:creategrid',{
                    'CRS': projection,
                    'EXTENT': ext,
                    'HOVERLAY': 0,
                    'HSPACING': dist_xy,
                    'TYPE': 2,
                    'VOVERLAY': 0,
                    'VSPACING': dist_xy,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                    })

                    output_grid = grid_diamond['OUTPUT']
                   
                except:
                    continue   
                
                    
                recorte = processing.run('native:clip',{
                'INPUT': output_grid,
                'OUTPUT': 'TEMPORARY_OUTPUT',
                'OVERLAY': b
                })

                output_recorte = recorte['OUTPUT']
                list_grid.append(output_recorte)
                
                
            return list_grid
            
            
        if self.dlg.radioButtonAbertura.isChecked() == True:
    
            list_grid_regular=__gerar_grid_regular__(list_geometria_corrigida, grid_value = self.valor_grade, padrao_value = self.Padrao, porcentagem_value = self.valor_aviao)
    
        
        if self.dlg.radioButtonLavoura.isChecked() == True:
            list_grid_regular=__gerar_grid_regular__(list_geometria_corrigida, grid_value = self.valor_grade, padrao_value = self.Padrao, porcentagem_value = self.valor_verde)
                
        


        def __mesclando_buffers__(output_buffer_list,  grid_value = int, padrao_value = str):
            name_padrao = 'GRADE ' + str(grid_value) + ' ' + padrao_value
            output_buffer_list
            print(output_buffer_list)
            ## MESCLANDO BUFFERS
            try:
                buffer_mesclado=processing.run('native:mergevectorlayers',{
                'CRS': None,
                'LAYERS':output_buffer_list ,
                'OUTPUT': 'TEMPORARY_OUTPUT'
                })
                output_buffer_mesclado = buffer_mesclado['OUTPUT']
                QgsProject.instance().addMapLayer(output_buffer_mesclado)
                old_name=QgsProject.instance().mapLayersByName("Mesclado")[0] 
                old_name.setName(name_padrao)
                output_buffer_mesclado.loadNamedStyle(os.path.join(self.plugin_dir,'grade_legenda.qml'))
                output_buffer_mesclado.triggerRepaint()
            except:
                pass
                output_buffer_mesclado = output_buffer_list
                QgsProject.instance().addMapLayer(output_buffer_mesclado)
                
                output_buffer_mesclado.loadNamedStyle(os.path.join(self.plugin_dir,'grade_legenda.qml'))
                output_buffer_mesclado.triggerRepaint()
                
            return output_buffer_mesclado, name_padrao
            
        mesclado, name_padrao=__mesclando_buffers__(list_grid_regular, grid_value = self.valor_grade, padrao_value = self.Padrao)


        # ## ESTRATIFICAÇÃO
        def __estratificar_ciquenta_porcento__(grid = int, padrao = str, value = str):
            layer = QgsProject.instance().mapLayersByName(nome_padrao_point)[0] # get the currently active layer
            percentage = 50 # set the percentage of features to select
            grid_value = grid
            padrao_value = padrao
            grid_filter = 'GRID = ' + str(grid_value)
            padrao_filter = "PADRAO = '" + padrao_value + "'"

            # Create a list of features in the layer that match the filter
            all_features = [feature for feature in layer.getFeatures(QgsFeatureRequest().setFilterExpression(grid_filter).setFilterExpression(padrao_filter))]

            # Select a percentage of the features in the filtered list, but only for odd 'ID' values
            n_total = len(all_features)
            n_selections = int(n_total * (percentage / 100))
            selected_features = []
            for feature in all_features:
                if feature['ID'] % 2 != 0:
                    selected_features.append(feature)
                    if len(selected_features) == n_selections:
                        break

            # Update the 'sym' field of the selected features
            layer.startEditing()
            for feature in selected_features:
                feature['sym'] = value
                layer.updateFeature(feature)
            layer.commitChanges()
            layer.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_gps13.qml'))
            layer.triggerRepaint()
            


        def __gerar_estratificacao__(name_padrao,name_padrao_point):
            point_layer = QgsProject.instance().mapLayersByName(name_padrao_point)[0]
            grid_layer = QgsProject.instance().mapLayersByName(name_padrao)[0]
            
            
            # Loop through each feature in grid layer
            for grid_feature in grid_layer.getFeatures():
                # Get geometry of current grid feature and its centroid
                grid_geom = grid_feature.geometry()
                grid_centroid = grid_geom.centroid()
                
                # Create a spatial index for the point layer
                point_index = QgsSpatialIndex(point_layer.getFeatures())
                
                # Get a list of point features that intersect the current grid feature's geometry
                point_ids = point_index.intersects(grid_geom.boundingBox())
                

                # Find the closest point feature to the grid feature's centroid within the grid feature's geometry
                closest_point = None
                min_distance = float('inf')
                for point_id in point_ids:
                    point_feature = point_layer.getFeature(point_id)
                    point_geom = point_feature.geometry()
                    if grid_geom.contains(point_geom) and grid_geom.contains(point_geom.centroid()):
                        distance = grid_centroid.distance(point_geom)
                        if distance < min_distance:
                            closest_point = point_feature
                            min_distance = distance

                # Select the closest point feature within the grid feature's geometry, if one was found
                if closest_point is not None:
                    # Check if the selected point is completely within the grid feature's geometry
                    point_geom = closest_point.geometry()
                    if grid_geom.contains(point_geom) and grid_geom.contains(point_geom.centroid()):
                        point_layer.select(closest_point.id())


        # __gerar_estratificacao__(name_padrao,nome_padrao_point)

        def __add_selecao__( padrao_value = str, grid_value = int, porcentagem_value = int, bandeira_value = str):
            import random
            layer = QgsProject.instance().mapLayersByName(nome_padrao_point)[0]
            #layer = point_layer
            geom_field = 'GEOMETRIA' # set the name of the geometry field
            grid_field = 'GRID' # set the name of the grid field
            padrao_field = 'PADRAO' # set the name of the padrao field
            
            porcentagem = porcentagem_value/100
            # create a dictionary to store the count of selected points and total points for each geometry value
            geom_counts = {}

            # get the total number of points for each geometry value
            for feature in layer.getFeatures():
                geom_value = feature[geom_field]
                if feature[grid_field] != grid_value or feature[padrao_field] != padrao_value:
                    continue
                if geom_value not in geom_counts:
                    geom_counts[geom_value] = {'total': 0, 'selected': 0}
                geom_counts[geom_value]['total'] += 1

            # get the set of selected feature IDs that meet the filter criteria
            selected_ids = set()
            for feature in layer.selectedFeatures():
                if feature[grid_field] == grid_value and feature[padrao_field] == padrao_value:
                    selected_ids.add(feature.id())

            # loop through all features in the layer and count the number of selected points for each geometry value
            for feature in layer.getFeatures():
                if feature[grid_field] != grid_value or feature[padrao_field] != padrao_value:
                    continue
                
                geom_value = feature[geom_field]
                selected_value = feature.id() in selected_ids
                
                if selected_value:
                    geom_counts[geom_value]['selected'] += 1
                   
                   
            # print the difference between the number of selected points and 25% of the total points for each geometry value
            for geom_value, counts in geom_counts.items():
                total_count = counts['total']
                selected_count = counts['selected']
                threshold = porcentagem * total_count
                diff = threshold - selected_count
                diff = int(diff)
                #print("Geometry: {0}, Selected points: {1}, Total points: {2}, Difference: {3}".format(geom_value, selected_count, total_count, diff))
                # if the difference is greater than 0, randomly add required amount to current selection
                if diff > 0:
                    # get a list of feature IDs for the points in the current geometry value
                    geom_feature_ids = [f.id() for f in layer.getFeatures() if f[geom_field] == geom_value]
                    
                    #randomly select features to add to the selection
                    add_ids = random.sample(geom_feature_ids, diff)
                    
                    # add the selected features to the current selection
                    #point_layer = QgsProject.instance().mapLayersByName('pt_nilto_utm')[0]
                    QgsProject.instance().addMapLayer(point_layer)
                    for add_id in add_ids:
                        point_layer.select(add_id)
            
           
            field_idx = layer.fields().indexFromName('sym') # get the index of the "sym" field
            selected_features = layer.selectedFeatures() # get the selected features
            
            # loop through the selected features and update the "sym" field value
            with edit(layer):
                for feature in selected_features:
                    feature[field_idx] = bandeira_value # set the new value of the "sym" field
                    layer.updateFeature(feature) # update the feature in the layer
            
            layer.commitChanges()
            layer.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_gps13.qml'))
            layer.triggerRepaint()

       
        def __flag_red__(porcentagem = int):
            porcentagem_value = porcentagem/100
            layer = QgsProject.instance().mapLayersByName(nome_padrao_point)[0]
            field_name = 'GEOMETRIA'
            layer.removeSelection()

            # Get unique values in 'GEOMETRIA' field
            unique_values = layer.uniqueValues(layer.fields().lookupField(field_name))

            # Loop through unique values
            for value in unique_values:
                # Select features based on 'GEOMETRIA' value
                expr = QgsExpression(f'"{field_name}" = \'{value}\'')
                expr2 = QgsExpression(f'"{field_name}" = \'{value}\' AND "sym" = \'Flag, Green\' AND "ID" % 2 = 1')
                selected_features = layer.getFeatures(QgsFeatureRequest(expr))
                selected_features_2 = layer.getFeatures(QgsFeatureRequest(expr2))

                # Get total number of selected features
                total_count = len(list(selected_features))
                #print(f'Total count for "{field_name}" = "{value}": {total_count}')

                # Reset iterator and loop through selected features to count 10% of them
                selected_features = layer.getFeatures(QgsFeatureRequest(expr))
                count = 0
                for feature in selected_features_2:
                    if count == round(total_count * porcentagem_value):
                        break
                    layer.select(feature.id())
                    count += 1

                #print(f'Count of selected features for "{field_name}" = "{value}": {count}')
            field_idx = layer.fields().indexFromName('sym') # get the index of the "sym" field
            selected_features = layer.selectedFeatures() # get the selected features
            
            # loop through the selected features and update the "sym" field value
            with edit(layer):
                for feature in selected_features:
                    feature[field_idx] = 'Flag, Red' # set the new value of the "sym" field
                    layer.updateFeature(feature) # update the feature in the layer
            
            layer.commitChanges()
            layer.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_gps13.qml'))
            layer.triggerRepaint()
        
        
        
        
        def __condional_red__():
            if self.valor_vermelho != 0 and self.dlg.checkBoxVermelho.isChecked() == True:
                __flag_red__(porcentagem = self.valor_vermelho)
            
        
        
        if self.valor_verde == 50 and self.dlg.checkBoxVerde.isChecked() == True:
            __estratificar_ciquenta_porcento__(grid = self.valor_grade, padrao = 'LAVOURA', value = 'Flag, Green')
            
            
        if self.valor_verde == 50 and self.dlg.checkBoxVerde.isChecked() == True and self.valor_vermelho != 0 and self.dlg.checkBoxVermelho.isChecked() == True:
            __estratificar_ciquenta_porcento__(grid = self.valor_grade, padrao = 'LAVOURA', value = 'Flag, Green')        
            __flag_red__(porcentagem = self.valor_vermelho)
        
  
        
        
        if self.valor_aviao == 50 and self.dlg.checkBoxAviao.isChecked() == True:
            __estratificar_ciquenta_porcento__(grid = self.valor_grade, padrao = 'ABERTURA', value = 'Airport')     
        
        
        
        
        if self.valor_verde != 50:
            __gerar_estratificacao__(name_padrao,nome_padrao_point)
            __add_selecao__(padrao_value = 'LAVOURA', grid_value = self.valor_grade, porcentagem_value = self.valor_verde, bandeira_value = 'Flag, Green')
            __add_selecao__(padrao_value = 'LAVOURA', grid_value = self.valor_grade, porcentagem_value = self.valor_verde, bandeira_value = 'Flag, Green')
            __condional_red__()
            
        
        
        if self.valor_aviao != 50 and self.valor_aviao != 0:
            __gerar_estratificacao__(name_padrao,nome_padrao_point)
            __add_selecao__(padrao_value = 'ABERTURA', grid_value = self.valor_grade, porcentagem_value = self.valor_aviao, bandeira_value = 'Airport')
            __add_selecao__(padrao_value = 'ABERTURA', grid_value = self.valor_grade, porcentagem_value = self.valor_aviao, bandeira_value = 'Airport')
            __condional_red__()    
            
       
         
        
